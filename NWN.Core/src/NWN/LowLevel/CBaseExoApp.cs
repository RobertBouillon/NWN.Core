// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NWN.LowLevel
{
    public unsafe partial class CConnectionLib
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NWN.LowLevel.CConnectionLib> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NWN.LowLevel.CConnectionLib>();

        protected bool __ownsNativeInstance;

        internal static CConnectionLib __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CConnectionLib(native.ToPointer(), skipVTables);
        }

        internal static CConnectionLib __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CConnectionLib)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CConnectionLib __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CConnectionLib(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CConnectionLib(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CConnectionLib(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CBaseExoApp : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr vptr_CBaseExoApp;

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN11CBaseExoAppC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN11CBaseExoAppC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NWN.LowLevel.CBaseExoApp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NWN.LowLevel.CBaseExoApp>();

        protected bool __ownsNativeInstance;

        internal static CBaseExoApp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CBaseExoApp(native.ToPointer(), skipVTables);
        }

        internal static CBaseExoApp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CBaseExoApp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CBaseExoApp __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new System.Exception("No managed instance was found");
            var result = (CBaseExoApp)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static CBaseExoApp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CBaseExoApp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NWN.LowLevel.CBaseExoApp.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private CBaseExoApp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CBaseExoApp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CBaseExoApp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NWN.LowLevel.CBaseExoApp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "NWN.LowLevel.CBaseExoApp");
        }

        public CBaseExoApp(global::NWN.LowLevel.CBaseExoApp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NWN.LowLevel.CBaseExoApp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "NWN.LowLevel.CBaseExoApp");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::NWN.LowLevel.CBaseExoApp __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::NWN.LowLevel.CBaseExoApp.__Internal*) __Instance)->vptr_CBaseExoApp = __VTables.Tables[0];
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public virtual int AdmitNetworkAddress(uint nProtocol, global::NWN.LowLevel.CExoString sAddress)
        {
            var ___AdmitNetworkAddressDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr_uint___IntPtr>(0, 0);
            if (ReferenceEquals(sAddress, null))
                throw new global::System.ArgumentNullException("sAddress", "Cannot be null because it is passed by value.");
            var __arg1 = sAddress.__Instance;
            var __ret = ___AdmitNetworkAddressDelegate(__Instance, nProtocol, __arg1);
            return __ret;
        }

        public virtual int AdmitPlayerName(global::NWN.LowLevel.CExoString sPlayerName)
        {
            var ___AdmitPlayerNameDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr>(0, 1);
            if (ReferenceEquals(sPlayerName, null))
                throw new global::System.ArgumentNullException("sPlayerName", "Cannot be null because it is passed by value.");
            var __arg0 = sPlayerName.__Instance;
            var __ret = ___AdmitPlayerNameDelegate(__Instance, __arg0);
            return __ret;
        }

        public virtual int SetNetworkAddressBan(uint nProtocol, global::NWN.LowLevel.CExoString sAddress, int bBanPlayer)
        {
            var ___SetNetworkAddressBanDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr_uint___IntPtr_int>(0, 2);
            if (ReferenceEquals(sAddress, null))
                throw new global::System.ArgumentNullException("sAddress", "Cannot be null because it is passed by value.");
            var __arg1 = sAddress.__Instance;
            var __ret = ___SetNetworkAddressBanDelegate(__Instance, nProtocol, __arg1, bBanPlayer);
            return __ret;
        }

        public virtual void PlayerListChange(uint nPlayerId, int bEnter, int bPrimaryPlayer)
        {
            var ___PlayerListChangeDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr_uint_int_int>(0, 3);
            ___PlayerListChangeDelegate(__Instance, nPlayerId, bEnter, bPrimaryPlayer);
        }

        public virtual int HandleMessage(uint nPlayerId, byte* pData, uint dwSize, int bRawMessage)
        {
            var ___HandleMessageDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr_uint_bytePtr_uint_int>(0, 4);
            var __ret = ___HandleMessageDelegate(__Instance, nPlayerId, pData, dwSize, bRawMessage);
            return __ret;
        }

        public virtual int ContinueMessageProcessing()
        {
            var ___ContinueMessageProcessingDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 6);
            var __ret = ___ContinueMessageProcessingDelegate(__Instance);
            return __ret;
        }

        public virtual void ShutDownToMainMenu()
        {
            var ___ShutDownToMainMenuDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr>(0, 8);
            ___ShutDownToMainMenuDelegate(__Instance);
        }

        public virtual void HandleGameSpyToServerMessage(int nKeyId, __IntPtr pOutBuf, int nIndex)
        {
            var ___HandleGameSpyToServerMessageDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr_int___IntPtr_int>(0, 11);
            ___HandleGameSpyToServerMessageDelegate(__Instance, nKeyId, pOutBuf, nIndex);
        }

        public virtual void SetApplicationIdsMatch(int b)
        {
            var ___SetApplicationIdsMatchDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr_int>(0, 17);
            ___SetApplicationIdsMatchDelegate(__Instance, b);
        }

        public virtual int GetIsIPOnBannedList(global::NWN.LowLevel.CExoString sIP)
        {
            var ___GetIsIPOnBannedListDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr>(0, 18);
            if (ReferenceEquals(sIP, null))
                throw new global::System.ArgumentNullException("sIP", "Cannot be null because it is passed by value.");
            var __arg0 = sIP.__Instance;
            var __ret = ___GetIsIPOnBannedListDelegate(__Instance, __arg0);
            return __ret;
        }

        public virtual int GetIsPlayerNameOnBannedList(global::NWN.LowLevel.CExoString sPlayerName)
        {
            var ___GetIsPlayerNameOnBannedListDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr>(0, 19);
            if (ReferenceEquals(sPlayerName, null))
                throw new global::System.ArgumentNullException("sPlayerName", "Cannot be null because it is passed by value.");
            var __arg0 = sPlayerName.__Instance;
            var __ret = ___GetIsPlayerNameOnBannedListDelegate(__Instance, __arg0);
            return __ret;
        }

        public virtual int GetIsCDKeyOnBannedList(global::NWN.LowLevel.CExoString sKey)
        {
            var ___GetIsCDKeyOnBannedListDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr>(0, 20);
            if (ReferenceEquals(sKey, null))
                throw new global::System.ArgumentNullException("sKey", "Cannot be null because it is passed by value.");
            var __arg0 = sKey.__Instance;
            var __ret = ___GetIsCDKeyOnBannedListDelegate(__Instance, __arg0);
            return __ret;
        }

        public virtual void HandleOldServerVaultMigration(global::NWN.LowLevel.CExoString sClientCDKey, global::NWN.LowLevel.CExoString sClientLegacyCDKey, global::NWN.LowLevel.CExoString sPlayerName)
        {
            var ___HandleOldServerVaultMigrationDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 21);
            if (ReferenceEquals(sClientCDKey, null))
                throw new global::System.ArgumentNullException("sClientCDKey", "Cannot be null because it is passed by value.");
            var __arg0 = sClientCDKey.__Instance;
            if (ReferenceEquals(sClientLegacyCDKey, null))
                throw new global::System.ArgumentNullException("sClientLegacyCDKey", "Cannot be null because it is passed by value.");
            var __arg1 = sClientLegacyCDKey.__Instance;
            if (ReferenceEquals(sPlayerName, null))
                throw new global::System.ArgumentNullException("sPlayerName", "Cannot be null because it is passed by value.");
            var __arg2 = sPlayerName.__Instance;
            ___HandleOldServerVaultMigrationDelegate(__Instance, __arg0, __arg1, __arg2);
        }

        public virtual int CheckStickyPlayerNameReserved(global::NWN.LowLevel.CExoString sClientCDKey, global::NWN.LowLevel.CExoString sClientLegacyCDKey, global::NWN.LowLevel.CExoString sPlayerName, int nConnectionType)
        {
            var ___CheckStickyPlayerNameReservedDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr___IntPtr___IntPtr_int>(0, 23);
            if (ReferenceEquals(sClientCDKey, null))
                throw new global::System.ArgumentNullException("sClientCDKey", "Cannot be null because it is passed by value.");
            var __arg0 = sClientCDKey.__Instance;
            if (ReferenceEquals(sClientLegacyCDKey, null))
                throw new global::System.ArgumentNullException("sClientLegacyCDKey", "Cannot be null because it is passed by value.");
            var __arg1 = sClientLegacyCDKey.__Instance;
            if (ReferenceEquals(sPlayerName, null))
                throw new global::System.ArgumentNullException("sPlayerName", "Cannot be null because it is passed by value.");
            var __arg2 = sPlayerName.__Instance;
            var __ret = ___CheckStickyPlayerNameReservedDelegate(__Instance, __arg0, __arg1, __arg2, nConnectionType);
            return __ret;
        }

        public virtual void PushMessageOverWall(byte* pData, uint nMsgLength)
        {
            var ___PushMessageOverWallDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr_bytePtr_uint>(0, 24);
            ___PushMessageOverWallDelegate(__Instance, pData, nMsgLength);
        }

        public virtual int GetCDKeys(global::NWN.LowLevel.CExoArrayList<global::NWN.LowLevel.CExoString> lstKeys)
        {
            var ___GetCDKeysDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr>(0, 26);
            var ____arg0 = lstKeys is null ? __IntPtr.Zero : lstKeys.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __ret = ___GetCDKeysDelegate(__Instance, __arg0);
            return __ret;
        }

        public virtual void SetWeGotDisconnected()
        {
            var ___SetWeGotDisconnectedDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr>(0, 27);
            ___SetWeGotDisconnectedDelegate(__Instance);
        }

        public virtual float FPS
        {
            get
            {
                var ___GetFPSDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_float___IntPtr>(0, 5);
                var __ret = ___GetFPSDelegate(__Instance);
                return __ret;
            }
        }

        public virtual global::NWN.LowLevel.CNetLayer NetLayer
        {
            get
            {
                var ___GetNetLayerDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr>(0, 7);
                var __ret = ___GetNetLayerDelegate(__Instance);
                var __result0 = global::NWN.LowLevel.CNetLayer.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public virtual int MultiplayerEnabled
        {
            get
            {
                var ___GetMultiplayerEnabledDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 9);
                var __ret = ___GetMultiplayerEnabledDelegate(__Instance);
                return __ret;
            }
        }

        public virtual global::NWN.LowLevel.CExtendedServerInfo ExtendedServerInfo
        {
            get
            {
                var ___GetExtendedServerInfoDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr>(0, 10);
                var __ret = ___GetExtendedServerInfoDelegate(__Instance);
                var __result0 = global::NWN.LowLevel.CExtendedServerInfo.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            set
            {
                var ___GetExtendedServerInfo_1Delegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr___IntPtr>(0, 14);
                var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                ___GetExtendedServerInfo_1Delegate(__Instance, __arg0);
            }
        }

        public virtual global::NWN.LowLevel.CConnectionLib ConnectionLib
        {
            get
            {
                var ___GetConnectionLibDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr>(0, 12);
                var __ret = ___GetConnectionLibDelegate(__Instance);
                var __result0 = global::NWN.LowLevel.CConnectionLib.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public virtual global::NWN.LowLevel.CServerInfo ServerInfo
        {
            get
            {
                var ___GetServerInfoDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr>(0, 13);
                var __ret = ___GetServerInfoDelegate(__Instance);
                var __result0 = global::NWN.LowLevel.CServerInfo.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public virtual global::NWN.LowLevel.CExoLocString ModuleDescription
        {
            get
            {
                var ___GetModuleDescriptionDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr___IntPtr>(0, 15);
                var __ret = new global::NWN.LowLevel.CExoLocString.__Internal();
                ___GetModuleDescriptionDelegate(new IntPtr(&__ret), __Instance);
                return global::NWN.LowLevel.CExoLocString.__CreateInstance(__ret);
            }
        }

        public virtual uint ApplicationId
        {
            get
            {
                var ___GetApplicationIdDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_uint___IntPtr>(0, 16);
                var __ret = ___GetApplicationIdDelegate(__Instance);
                return __ret;
            }
        }

        public virtual int IsPlayerNameSticky
        {
            get
            {
                var ___IsPlayerNameStickyDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 22);
                var __ret = ___IsPlayerNameStickyDelegate(__Instance);
                return __ret;
            }
        }

        public virtual int IsMultiPlayer
        {
            get
            {
                var ___GetIsMultiPlayerDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 25);
                var __ret = ___GetIsMultiPlayerDelegate(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // BOOL AdmitNetworkAddress(uint32_t nProtocol, CExoString sAddress)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr_uint___IntPtr _AdmitNetworkAddressDelegateInstance;

        private static int _AdmitNetworkAddressDelegateHook(__IntPtr __instance, uint nProtocol, __IntPtr sAddress)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result1 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sAddress, false);
            return __target.AdmitNetworkAddress(nProtocol, __result1);
        }

        // BOOL AdmitPlayerName(CExoString sPlayerName)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr _AdmitPlayerNameDelegateInstance;

        private static int _AdmitPlayerNameDelegateHook(__IntPtr __instance, __IntPtr sPlayerName)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result0 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sPlayerName, false);
            return __target.AdmitPlayerName(__result0);
        }

        // BOOL SetNetworkAddressBan(uint32_t nProtocol, CExoString sAddress, BOOL bBanPlayer)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr_uint___IntPtr_int _SetNetworkAddressBanDelegateInstance;

        private static int _SetNetworkAddressBanDelegateHook(__IntPtr __instance, uint nProtocol, __IntPtr sAddress, int bBanPlayer)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result1 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sAddress, false);
            return __target.SetNetworkAddressBan(nProtocol, __result1, bBanPlayer);
        }

        // void PlayerListChange(uint32_t nPlayerId, BOOL bEnter, BOOL bPrimaryPlayer = false)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr_uint_int_int _PlayerListChangeDelegateInstance;

        private static void _PlayerListChangeDelegateHook(__IntPtr __instance, uint nPlayerId, int bEnter, int bPrimaryPlayer)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            __target.PlayerListChange(nPlayerId, bEnter, bPrimaryPlayer);
        }

        // BOOL HandleMessage(uint32_t nPlayerId, uint8_t * pData, uint32_t dwSize, BOOL bRawMessage)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr_uint_bytePtr_uint_int _HandleMessageDelegateInstance;

        private static int _HandleMessageDelegateHook(__IntPtr __instance, uint nPlayerId, byte* pData, uint dwSize, int bRawMessage)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            return __target.HandleMessage(nPlayerId, pData, dwSize, bRawMessage);
        }

        // float GetFPS()
        private static global::NWN.LowLevel.Delegates.Func_float___IntPtr _GetFPSDelegateInstance;

        private static float _GetFPSDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            return __target.FPS;
        }

        // BOOL ContinueMessageProcessing()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _ContinueMessageProcessingDelegateInstance;

        private static int _ContinueMessageProcessingDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            return __target.ContinueMessageProcessing();
        }

        // class CNetLayer * GetNetLayer()
        private static global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr _GetNetLayerDelegateInstance;

        private static __IntPtr _GetNetLayerDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __ret = __target.NetLayer;
            return __ret is null ? __IntPtr.Zero : __ret.__Instance;
        }

        // void ShutDownToMainMenu()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _ShutDownToMainMenuDelegateInstance;

        private static void _ShutDownToMainMenuDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            __target.ShutDownToMainMenu();
        }

        // BOOL GetMultiplayerEnabled()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _GetMultiplayerEnabledDelegateInstance;

        private static int _GetMultiplayerEnabledDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            return __target.MultiplayerEnabled;
        }

        // class CExtendedServerInfo * GetExtendedServerInfo()
        private static global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr _GetExtendedServerInfoDelegateInstance;

        private static __IntPtr _GetExtendedServerInfoDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __ret = __target.ExtendedServerInfo;
            return __ret is null ? __IntPtr.Zero : __ret.__Instance;
        }

        // void HandleGameSpyToServerMessage(int32_t nKeyId, void * pOutBuf, int nIndex = - 1)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr_int___IntPtr_int _HandleGameSpyToServerMessageDelegateInstance;

        private static void _HandleGameSpyToServerMessageDelegateHook(__IntPtr __instance, int nKeyId, __IntPtr pOutBuf, int nIndex)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            __target.HandleGameSpyToServerMessage(nKeyId, pOutBuf, nIndex);
        }

        // class CConnectionLib * GetConnectionLib()
        private static global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr _GetConnectionLibDelegateInstance;

        private static __IntPtr _GetConnectionLibDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __ret = __target.ConnectionLib;
            return __ret is null ? __IntPtr.Zero : __ret.__Instance;
        }

        // class CServerInfo * GetServerInfo()
        private static global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr _GetServerInfoDelegateInstance;

        private static __IntPtr _GetServerInfoDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __ret = __target.ServerInfo;
            return __ret is null ? __IntPtr.Zero : __ret.__Instance;
        }

        // void GetExtendedServerInfo(class CExtendedServerInfo * pInfo)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr___IntPtr _GetExtendedServerInfo_1DelegateInstance;

        private static void _GetExtendedServerInfo_1DelegateHook(__IntPtr __instance, __IntPtr pInfo)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result0 = global::NWN.LowLevel.CExtendedServerInfo.__GetOrCreateInstance(pInfo, false);
            __target.ExtendedServerInfo = __result0;
        }

        // CExoLocString GetModuleDescription()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr___IntPtr _GetModuleDescriptionDelegateInstance;

        private static void _GetModuleDescriptionDelegateHook(__IntPtr @return, __IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __ret = __target.ModuleDescription;
            if (ReferenceEquals(__ret, null))
                throw new global::System.ArgumentNullException("__ret", "Cannot be null because it is passed by value.");
            *(global::NWN.LowLevel.CExoLocString.__Internal*) @return = *(global::NWN.LowLevel.CExoLocString.__Internal*) __ret.__Instance;
        }

        // uint32_t GetApplicationId()
        private static global::NWN.LowLevel.Delegates.Func_uint___IntPtr _GetApplicationIdDelegateInstance;

        private static uint _GetApplicationIdDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            return __target.ApplicationId;
        }

        // void SetApplicationIdsMatch(BOOL b)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr_int _SetApplicationIdsMatchDelegateInstance;

        private static void _SetApplicationIdsMatchDelegateHook(__IntPtr __instance, int b)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            __target.SetApplicationIdsMatch(b);
        }

        // BOOL GetIsIPOnBannedList(CExoString sIP)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr _GetIsIPOnBannedListDelegateInstance;

        private static int _GetIsIPOnBannedListDelegateHook(__IntPtr __instance, __IntPtr sIP)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result0 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sIP, false);
            return __target.GetIsIPOnBannedList(__result0);
        }

        // BOOL GetIsPlayerNameOnBannedList(CExoString sPlayerName)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr _GetIsPlayerNameOnBannedListDelegateInstance;

        private static int _GetIsPlayerNameOnBannedListDelegateHook(__IntPtr __instance, __IntPtr sPlayerName)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result0 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sPlayerName, false);
            return __target.GetIsPlayerNameOnBannedList(__result0);
        }

        // BOOL GetIsCDKeyOnBannedList(CExoString sKey)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr _GetIsCDKeyOnBannedListDelegateInstance;

        private static int _GetIsCDKeyOnBannedListDelegateHook(__IntPtr __instance, __IntPtr sKey)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result0 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sKey, false);
            return __target.GetIsCDKeyOnBannedList(__result0);
        }

        // void HandleOldServerVaultMigration(CExoString sClientCDKey, CExoString sClientLegacyCDKey, CExoString sPlayerName)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _HandleOldServerVaultMigrationDelegateInstance;

        private static void _HandleOldServerVaultMigrationDelegateHook(__IntPtr __instance, __IntPtr sClientCDKey, __IntPtr sClientLegacyCDKey, __IntPtr sPlayerName)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result0 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sClientCDKey, false);
            var __result1 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sClientLegacyCDKey, false);
            var __result2 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sPlayerName, false);
            __target.HandleOldServerVaultMigration(__result0, __result1, __result2);
        }

        // BOOL IsPlayerNameSticky()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _IsPlayerNameStickyDelegateInstance;

        private static int _IsPlayerNameStickyDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            return __target.IsPlayerNameSticky;
        }

        // BOOL CheckStickyPlayerNameReserved(CExoString sClientCDKey, CExoString sClientLegacyCDKey, CExoString sPlayerName, int32_t nConnectionType)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr___IntPtr___IntPtr_int _CheckStickyPlayerNameReservedDelegateInstance;

        private static int _CheckStickyPlayerNameReservedDelegateHook(__IntPtr __instance, __IntPtr sClientCDKey, __IntPtr sClientLegacyCDKey, __IntPtr sPlayerName, int nConnectionType)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            var __result0 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sClientCDKey, false);
            var __result1 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sClientLegacyCDKey, false);
            var __result2 = global::NWN.LowLevel.CExoString.__GetOrCreateInstance(sPlayerName, false);
            return __target.CheckStickyPlayerNameReserved(__result0, __result1, __result2, nConnectionType);
        }

        // void PushMessageOverWall(uint8_t * pData, uint32_t nMsgLength)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr_bytePtr_uint _PushMessageOverWallDelegateInstance;

        private static void _PushMessageOverWallDelegateHook(__IntPtr __instance, byte* pData, uint nMsgLength)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            __target.PushMessageOverWall(pData, nMsgLength);
        }

        // BOOL GetIsMultiPlayer()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _GetIsMultiPlayerDelegateInstance;

        private static int _GetIsMultiPlayerDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            return __target.IsMultiPlayer;
        }

        // BOOL GetCDKeys(CExoArrayList<CExoString> * * lstKeys)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr___IntPtr _GetCDKeysDelegateInstance;

        private static int _GetCDKeysDelegateHook(__IntPtr __instance, __IntPtr lstKeys)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            __IntPtr __lstKeys = lstKeys == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) lstKeys);
            var __result0 = global::NWN.LowLevel.CExoArrayList<global::NWN.LowLevel.CExoString>.__GetOrCreateInstance(__lstKeys, false);
            return __target.GetCDKeys(__result0);
        }

        // void SetWeGotDisconnected()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _SetWeGotDisconnectedDelegateInstance;

        private static void _SetWeGotDisconnectedDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CBaseExoApp.__GetInstance(__instance);
            __target.SetWeGotDisconnected();
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[28];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _AdmitNetworkAddressDelegateInstance += _AdmitNetworkAddressDelegateHook;
                _AdmitPlayerNameDelegateInstance += _AdmitPlayerNameDelegateHook;
                _SetNetworkAddressBanDelegateInstance += _SetNetworkAddressBanDelegateHook;
                _PlayerListChangeDelegateInstance += _PlayerListChangeDelegateHook;
                _HandleMessageDelegateInstance += _HandleMessageDelegateHook;
                _GetFPSDelegateInstance += _GetFPSDelegateHook;
                _ContinueMessageProcessingDelegateInstance += _ContinueMessageProcessingDelegateHook;
                _GetNetLayerDelegateInstance += _GetNetLayerDelegateHook;
                _ShutDownToMainMenuDelegateInstance += _ShutDownToMainMenuDelegateHook;
                _GetMultiplayerEnabledDelegateInstance += _GetMultiplayerEnabledDelegateHook;
                _GetExtendedServerInfoDelegateInstance += _GetExtendedServerInfoDelegateHook;
                _HandleGameSpyToServerMessageDelegateInstance += _HandleGameSpyToServerMessageDelegateHook;
                _GetConnectionLibDelegateInstance += _GetConnectionLibDelegateHook;
                _GetServerInfoDelegateInstance += _GetServerInfoDelegateHook;
                _GetExtendedServerInfo_1DelegateInstance += _GetExtendedServerInfo_1DelegateHook;
                _GetModuleDescriptionDelegateInstance += _GetModuleDescriptionDelegateHook;
                _GetApplicationIdDelegateInstance += _GetApplicationIdDelegateHook;
                _SetApplicationIdsMatchDelegateInstance += _SetApplicationIdsMatchDelegateHook;
                _GetIsIPOnBannedListDelegateInstance += _GetIsIPOnBannedListDelegateHook;
                _GetIsPlayerNameOnBannedListDelegateInstance += _GetIsPlayerNameOnBannedListDelegateHook;
                _GetIsCDKeyOnBannedListDelegateInstance += _GetIsCDKeyOnBannedListDelegateHook;
                _HandleOldServerVaultMigrationDelegateInstance += _HandleOldServerVaultMigrationDelegateHook;
                _IsPlayerNameStickyDelegateInstance += _IsPlayerNameStickyDelegateHook;
                _CheckStickyPlayerNameReservedDelegateInstance += _CheckStickyPlayerNameReservedDelegateHook;
                _PushMessageOverWallDelegateInstance += _PushMessageOverWallDelegateHook;
                _GetIsMultiPlayerDelegateInstance += _GetIsMultiPlayerDelegateHook;
                _GetCDKeysDelegateInstance += _GetCDKeysDelegateHook;
                _SetWeGotDisconnectedDelegateInstance += _SetWeGotDisconnectedDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AdmitNetworkAddressDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AdmitPlayerNameDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetNetworkAddressBanDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_PlayerListChangeDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_HandleMessageDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFPSDelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ContinueMessageProcessingDelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetNetLayerDelegateInstance);
                Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ShutDownToMainMenuDelegateInstance);
                Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetMultiplayerEnabledDelegateInstance);
                Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetExtendedServerInfoDelegateInstance);
                Thunks[11] = Marshal.GetFunctionPointerForDelegate(_HandleGameSpyToServerMessageDelegateInstance);
                Thunks[12] = Marshal.GetFunctionPointerForDelegate(_GetConnectionLibDelegateInstance);
                Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetServerInfoDelegateInstance);
                Thunks[14] = Marshal.GetFunctionPointerForDelegate(_GetExtendedServerInfo_1DelegateInstance);
                Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetModuleDescriptionDelegateInstance);
                Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetApplicationIdDelegateInstance);
                Thunks[17] = Marshal.GetFunctionPointerForDelegate(_SetApplicationIdsMatchDelegateInstance);
                Thunks[18] = Marshal.GetFunctionPointerForDelegate(_GetIsIPOnBannedListDelegateInstance);
                Thunks[19] = Marshal.GetFunctionPointerForDelegate(_GetIsPlayerNameOnBannedListDelegateInstance);
                Thunks[20] = Marshal.GetFunctionPointerForDelegate(_GetIsCDKeyOnBannedListDelegateInstance);
                Thunks[21] = Marshal.GetFunctionPointerForDelegate(_HandleOldServerVaultMigrationDelegateInstance);
                Thunks[22] = Marshal.GetFunctionPointerForDelegate(_IsPlayerNameStickyDelegateInstance);
                Thunks[23] = Marshal.GetFunctionPointerForDelegate(_CheckStickyPlayerNameReservedDelegateInstance);
                Thunks[24] = Marshal.GetFunctionPointerForDelegate(_PushMessageOverWallDelegateInstance);
                Thunks[25] = Marshal.GetFunctionPointerForDelegate(_GetIsMultiPlayerDelegateInstance);
                Thunks[26] = Marshal.GetFunctionPointerForDelegate(_GetCDKeysDelegateInstance);
                Thunks[27] = Marshal.GetFunctionPointerForDelegate(_SetWeGotDisconnectedDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 30);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            ManagedVTables[0][4] = Thunks[4];
                            ManagedVTables[0][5] = Thunks[5];
                            ManagedVTables[0][6] = Thunks[6];
                            ManagedVTables[0][7] = Thunks[7];
                            ManagedVTables[0][8] = Thunks[8];
                            ManagedVTables[0][9] = Thunks[9];
                            ManagedVTables[0][10] = Thunks[10];
                            ManagedVTables[0][11] = Thunks[11];
                            ManagedVTables[0][12] = Thunks[12];
                            ManagedVTables[0][13] = Thunks[13];
                            ManagedVTables[0][14] = Thunks[14];
                            ManagedVTables[0][15] = Thunks[15];
                            ManagedVTables[0][16] = Thunks[16];
                            ManagedVTables[0][17] = Thunks[17];
                            ManagedVTables[0][18] = Thunks[18];
                            ManagedVTables[0][19] = Thunks[19];
                            ManagedVTables[0][20] = Thunks[20];
                            ManagedVTables[0][21] = Thunks[21];
                            ManagedVTables[0][22] = Thunks[22];
                            ManagedVTables[0][23] = Thunks[23];
                            ManagedVTables[0][24] = Thunks[24];
                            ManagedVTables[0][25] = Thunks[25];
                            ManagedVTables[0][26] = Thunks[26];
                            ManagedVTables[0][27] = Thunks[27];
                            VTables.Methods[0] = new Delegate[30];
                            if (destructorOnly)
                                return VTables;
                        }
                    }
                }

                *(IntPtr**)(instance + 0) = ManagedVTables[0];
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__S_CExoString___S_CNWSScriptVar
        {
            [FieldOffset(0)]
            internal global::NWN.LowLevel.CExoString.__Internal first;

            [FieldOffset(16)]
            internal global::NWN.LowLevel.CNWSScriptVar.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_N___cxx11_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___S_CachedRulesetEntry
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_N___cxx11_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::NWN.LowLevel.CachedRulesetEntry.__Internal second;
        }
    }

}
namespace Std
{
    namespace Hashtable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public unsafe partial struct __Internalc__N_std_S__Hashtable____S_CExoString___N_std_S_pair__1S0____S_CNWSScriptVar___N_std_S_allocator__S1____N_std_N___detail_S__Select1st___N_std_S_equal_to__S0____N_std_S_hash__S0____N_std_N___detail_S__Mod_range_hashing___N_std_N___detail_S__Default_ranged_hash___N_std_N___detail_S__Prime_rehash_policy___N_std_N___detail_S__Hashtable_traits__Vb1_Vb0_Vb1
        {
            [FieldOffset(0)]
            internal __IntPtr _M_buckets;

            [FieldOffset(8)]
            internal ulong _M_bucket_count;

            [FieldOffset(16)]
            internal global::Std.Detail.HashNodeBase.__Internal _M_before_begin;

            [FieldOffset(24)]
            internal ulong _M_element_count;

            [FieldOffset(32)]
            internal global::Std.Detail.PrimeRehashPolicy.__Internal _M_rehash_policy;

            [FieldOffset(48)]
            internal __IntPtr _M_single_bucket;
        }
    }
}
