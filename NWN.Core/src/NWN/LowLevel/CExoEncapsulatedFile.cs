// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NWN.LowLevel
{
    public unsafe partial class CExoEncapsulatedFile : global::NWN.LowLevel.CExoPackedFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr vptr_CExoPackedFile;

            [FieldOffset(8)]
            internal global::NWN.LowLevel.CExoString.__Internal m_sFileName;

            [FieldOffset(24)]
            internal ushort m_wDrives;

            [FieldOffset(28)]
            internal uint m_nFileSize;

            [FieldOffset(32)]
            internal __IntPtr m_pExoFile;

            [FieldOffset(40)]
            internal __IntPtr m_pAsyncExoFile;

            [FieldOffset(48)]
            internal int m_nRefCount;

            [FieldOffset(52)]
            internal int m_nAsyncRefCount;

            [FieldOffset(56)]
            internal int m_bLoaded;

            [FieldOffset(60)]
            internal int m_bAsyncLoaded;

            [FieldOffset(64)]
            internal int m_bHeaderLoaded;

            [FieldOffset(72)]
            internal global::NWN.LowLevel.CExoLocString.__Internal m_lsDescription;

            [FieldOffset(88)]
            internal __IntPtr m_pEncapsulatedHeader;

            [FieldOffset(96)]
            internal __IntPtr m_pResListEntry;

            [FieldOffset(104)]
            internal byte m_nFileType;

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN20CExoEncapsulatedFileC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN20CExoEncapsulatedFileC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        internal static new CExoEncapsulatedFile __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CExoEncapsulatedFile(native.ToPointer(), skipVTables);
        }

        internal static new CExoEncapsulatedFile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CExoEncapsulatedFile)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static new CExoEncapsulatedFile __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new System.Exception("No managed instance was found");
            var result = (CExoEncapsulatedFile)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static CExoEncapsulatedFile __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CExoEncapsulatedFile(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NWN.LowLevel.CExoEncapsulatedFile.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private CExoEncapsulatedFile(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CExoEncapsulatedFile(void* native, bool skipVTables = false)
            : base((void*) native)
        {
            if (native == null)
                return;
            if (!skipVTables)
                SetupVTables(true);
        }

        public CExoEncapsulatedFile()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NWN.LowLevel.CExoEncapsulatedFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "NWN.LowLevel.CExoEncapsulatedFile");
        }

        public CExoEncapsulatedFile(global::NWN.LowLevel.CExoEncapsulatedFile _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NWN.LowLevel.CExoEncapsulatedFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "NWN.LowLevel.CExoEncapsulatedFile");
        }

        public override void AddRefCount()
        {
            base.AddRefCount();
        }

        public override void AddAsyncRefCount()
        {
            base.AddAsyncRefCount();
        }

        public override int CloseFile()
        {
            return base.CloseFile();
        }

        public override int CloseAsyncFile()
        {
            return base.CloseAsyncFile();
        }

        public override void DeleteRefCount()
        {
            base.DeleteRefCount();
        }

        public override void DeleteAsyncRefCount()
        {
            base.DeleteAsyncRefCount();
        }

        public override uint GetResourceSize(global::NWN.LowLevel.RESID nID)
        {
            return base.GetResourceSize(nID);
        }

        public override int Initialize()
        {
            return base.Initialize();
        }

        public override int OpenFile()
        {
            return base.OpenFile();
        }

        public override int OpenFile(byte* pCipher)
        {
            return base.OpenFile(pCipher);
        }

        public override int OpenAsyncFile()
        {
            return base.OpenAsyncFile();
        }

        public override uint ReadResource(global::NWN.LowLevel.RESID nID, __IntPtr pData, uint nSize, uint nDataOffset)
        {
            return base.ReadResource(nID, pData, nSize, nDataOffset);
        }

        public override void ReadResourceAsync(global::NWN.LowLevel.RESID nID, __IntPtr pData, uint nSize, uint nDataOffset)
        {
            base.ReadResourceAsync(nID, pData, nSize, nDataOffset);
        }

        public override int LoadHeader(byte nType)
        {
            return base.LoadHeader(nType);
        }

        public override int UnloadHeader()
        {
            return base.UnloadHeader();
        }

        public global::NWN.LowLevel.CExoLocString MLsDescription
        {
            get
            {
                return global::NWN.LowLevel.CExoLocString.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_lsDescription));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->m_lsDescription = *(global::NWN.LowLevel.CExoLocString.__Internal*) value.__Instance;
            }
        }

        public global::NWN.LowLevel.ENCAPSULATED_HEADER MPEncapsulatedHeader
        {
            get
            {
                var __result0 = global::NWN.LowLevel.ENCAPSULATED_HEADER.__GetOrCreateInstance(((__Internal*)__Instance)->m_pEncapsulatedHeader, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->m_pEncapsulatedHeader = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::NWN.LowLevel.ENCAPSULATED_RESLISTENTRY_E1 MPResListEntry
        {
            get
            {
                var __result0 = global::NWN.LowLevel.ENCAPSULATED_RESLISTENTRY_E1.__GetOrCreateInstance(((__Internal*)__Instance)->m_pResListEntry, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->m_pResListEntry = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public byte MNFileType
        {
            get
            {
                return ((__Internal*)__Instance)->m_nFileType;
            }

            set
            {
                ((__Internal*)__Instance)->m_nFileType = value;
            }
        }

        #region Virtual table interop

        // ~CExoEncapsulatedFile()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            __target.Dispose(true);
        }

        // void AddRefCount()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _AddRefCountDelegateInstance;

        private static void _AddRefCountDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            __target.AddRefCount();
        }

        // void AddAsyncRefCount()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _AddAsyncRefCountDelegateInstance;

        private static void _AddAsyncRefCountDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            __target.AddAsyncRefCount();
        }

        // BOOL CloseFile()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _CloseFileDelegateInstance;

        private static int _CloseFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.CloseFile();
        }

        // BOOL CloseAsyncFile()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _CloseAsyncFileDelegateInstance;

        private static int _CloseAsyncFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.CloseAsyncFile();
        }

        // void DeleteRefCount()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _DeleteRefCountDelegateInstance;

        private static void _DeleteRefCountDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            __target.DeleteRefCount();
        }

        // void DeleteAsyncRefCount()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _DeleteAsyncRefCountDelegateInstance;

        private static void _DeleteAsyncRefCountDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            __target.DeleteAsyncRefCount();
        }

        // CExoFile * GetFile()
        private static global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr _GetFileDelegateInstance;

        private static __IntPtr _GetFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            var __ret = __target.File;
            return __ret is null ? __IntPtr.Zero : __ret.__Instance;
        }

        // CExoFile * GetAsyncFile()
        private static global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr _GetAsyncFileDelegateInstance;

        private static __IntPtr _GetAsyncFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            var __ret = __target.AsyncFile;
            return __ret is null ? __IntPtr.Zero : __ret.__Instance;
        }

        // uint32_t GetResourceSize(RESID nID)
        private static global::NWN.LowLevel.Delegates.Func_uint___IntPtr_NWN_LowLevel_RESID___Internal _GetResourceSizeDelegateInstance;

        private static uint _GetResourceSizeDelegateHook(__IntPtr __instance, global::NWN.LowLevel.RESID.__Internal nID)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.GetResourceSize(global::NWN.LowLevel.RESID.__CreateInstance(nID));
        }

        // BOOL Initialize()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _InitializeDelegateInstance;

        private static int _InitializeDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.Initialize();
        }

        // BOOL OpenFile()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _OpenFileDelegateInstance;

        private static int _OpenFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.OpenFile();
        }

        // BOOL OpenFile(uint8_t * pCipher)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr_bytePtr _OpenFile_1DelegateInstance;

        private static int _OpenFile_1DelegateHook(__IntPtr __instance, byte* pCipher)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.OpenFile(pCipher);
        }

        // BOOL OpenAsyncFile()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _OpenAsyncFileDelegateInstance;

        private static int _OpenAsyncFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.OpenAsyncFile();
        }

        // uint32_t ReadResource(RESID nID, void * pData, uint32_t nSize, uint32_t nDataOffset)
        private static global::NWN.LowLevel.Delegates.Func_uint___IntPtr_NWN_LowLevel_RESID___Internal___IntPtr_uint_uint _ReadResourceDelegateInstance;

        private static uint _ReadResourceDelegateHook(__IntPtr __instance, global::NWN.LowLevel.RESID.__Internal nID, __IntPtr pData, uint nSize, uint nDataOffset)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.ReadResource(global::NWN.LowLevel.RESID.__CreateInstance(nID), pData, nSize, nDataOffset);
        }

        // void ReadResourceAsync(RESID nID, void * pData, uint32_t nSize, uint32_t nDataOffset)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr_NWN_LowLevel_RESID___Internal___IntPtr_uint_uint _ReadResourceAsyncDelegateInstance;

        private static void _ReadResourceAsyncDelegateHook(__IntPtr __instance, global::NWN.LowLevel.RESID.__Internal nID, __IntPtr pData, uint nSize, uint nDataOffset)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            __target.ReadResourceAsync(global::NWN.LowLevel.RESID.__CreateInstance(nID), pData, nSize, nDataOffset);
        }

        // BOOL LoadHeader(uint8_t nType = 0)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr_byte _LoadHeaderDelegateInstance;

        private static int _LoadHeaderDelegateHook(__IntPtr __instance, byte nType)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.LoadHeader(nType);
        }

        // BOOL UnloadHeader()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _UnloadHeaderDelegateInstance;

        private static int _UnloadHeaderDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoEncapsulatedFile.__GetInstance(__instance);
            return __target.UnloadHeader();
        }

        internal static new class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[18];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _AddRefCountDelegateInstance += _AddRefCountDelegateHook;
                _AddAsyncRefCountDelegateInstance += _AddAsyncRefCountDelegateHook;
                _CloseFileDelegateInstance += _CloseFileDelegateHook;
                _CloseAsyncFileDelegateInstance += _CloseAsyncFileDelegateHook;
                _DeleteRefCountDelegateInstance += _DeleteRefCountDelegateHook;
                _DeleteAsyncRefCountDelegateInstance += _DeleteAsyncRefCountDelegateHook;
                _GetFileDelegateInstance += _GetFileDelegateHook;
                _GetAsyncFileDelegateInstance += _GetAsyncFileDelegateHook;
                _GetResourceSizeDelegateInstance += _GetResourceSizeDelegateHook;
                _InitializeDelegateInstance += _InitializeDelegateHook;
                _OpenFileDelegateInstance += _OpenFileDelegateHook;
                _OpenFile_1DelegateInstance += _OpenFile_1DelegateHook;
                _OpenAsyncFileDelegateInstance += _OpenAsyncFileDelegateHook;
                _ReadResourceDelegateInstance += _ReadResourceDelegateHook;
                _ReadResourceAsyncDelegateInstance += _ReadResourceAsyncDelegateHook;
                _LoadHeaderDelegateInstance += _LoadHeaderDelegateHook;
                _UnloadHeaderDelegateInstance += _UnloadHeaderDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AddRefCountDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AddAsyncRefCountDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_CloseFileDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_CloseAsyncFileDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_DeleteRefCountDelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_DeleteAsyncRefCountDelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetFileDelegateInstance);
                Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetAsyncFileDelegateInstance);
                Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetResourceSizeDelegateInstance);
                Thunks[10] = Marshal.GetFunctionPointerForDelegate(_InitializeDelegateInstance);
                Thunks[11] = Marshal.GetFunctionPointerForDelegate(_OpenFileDelegateInstance);
                Thunks[12] = Marshal.GetFunctionPointerForDelegate(_OpenFile_1DelegateInstance);
                Thunks[13] = Marshal.GetFunctionPointerForDelegate(_OpenAsyncFileDelegateInstance);
                Thunks[14] = Marshal.GetFunctionPointerForDelegate(_ReadResourceDelegateInstance);
                Thunks[15] = Marshal.GetFunctionPointerForDelegate(_ReadResourceAsyncDelegateInstance);
                Thunks[16] = Marshal.GetFunctionPointerForDelegate(_LoadHeaderDelegateInstance);
                Thunks[17] = Marshal.GetFunctionPointerForDelegate(_UnloadHeaderDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 21);
                            ManagedVTablesDtorOnly[0][1] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 21);
                            ManagedVTables[0][1] = Thunks[0];
                            ManagedVTables[0][2] = Thunks[1];
                            ManagedVTables[0][3] = Thunks[2];
                            ManagedVTables[0][4] = Thunks[3];
                            ManagedVTables[0][5] = Thunks[4];
                            ManagedVTables[0][6] = Thunks[5];
                            ManagedVTables[0][7] = Thunks[6];
                            ManagedVTables[0][8] = Thunks[7];
                            ManagedVTables[0][9] = Thunks[8];
                            ManagedVTables[0][10] = Thunks[9];
                            ManagedVTables[0][11] = Thunks[10];
                            ManagedVTables[0][12] = Thunks[11];
                            ManagedVTables[0][13] = Thunks[12];
                            ManagedVTables[0][14] = Thunks[13];
                            ManagedVTables[0][15] = Thunks[14];
                            ManagedVTables[0][16] = Thunks[15];
                            ManagedVTables[0][17] = Thunks[16];
                            ManagedVTables[0][18] = Thunks[17];
                            VTables.Methods[0] = new Delegate[21];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        internal override CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal override void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__S_CExoString___S_CNWSScriptVar
        {
            [FieldOffset(0)]
            internal global::NWN.LowLevel.CExoString.__Internal first;

            [FieldOffset(16)]
            internal global::NWN.LowLevel.CNWSScriptVar.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_N___cxx11_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___S_CachedRulesetEntry
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_N___cxx11_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::NWN.LowLevel.CachedRulesetEntry.__Internal second;
        }
    }

}
namespace Std
{
    namespace Hashtable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public unsafe partial struct __Internalc__N_std_S__Hashtable____S_CExoString___N_std_S_pair__1S0____S_CNWSScriptVar___N_std_S_allocator__S1____N_std_N___detail_S__Select1st___N_std_S_equal_to__S0____N_std_S_hash__S0____N_std_N___detail_S__Mod_range_hashing___N_std_N___detail_S__Default_ranged_hash___N_std_N___detail_S__Prime_rehash_policy___N_std_N___detail_S__Hashtable_traits__Vb1_Vb0_Vb1
        {
            [FieldOffset(0)]
            internal __IntPtr _M_buckets;

            [FieldOffset(8)]
            internal ulong _M_bucket_count;

            [FieldOffset(16)]
            internal global::Std.Detail.HashNodeBase.__Internal _M_before_begin;

            [FieldOffset(24)]
            internal ulong _M_element_count;

            [FieldOffset(32)]
            internal global::Std.Detail.PrimeRehashPolicy.__Internal _M_rehash_policy;

            [FieldOffset(48)]
            internal __IntPtr _M_single_bucket;
        }
    }
}
