// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NWN.LowLevel
{
    public unsafe partial class CNWSTile : global::NWN.LowLevel.CNWTile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr vptr_CNWTile;

            [FieldOffset(8)]
            internal global::NWN.LowLevel.Vector.__Internal m_vModelPosition;

            [FieldOffset(20)]
            internal int m_nID;

            [FieldOffset(24)]
            internal int m_nHeight;

            [FieldOffset(28)]
            internal int m_nGridX;

            [FieldOffset(32)]
            internal int m_nGridY;

            [FieldOffset(36)]
            internal int m_nOrientation;

            [FieldOffset(40)]
            internal byte m_nMainLight1Color;

            [FieldOffset(41)]
            internal byte m_nMainLight2Color;

            [FieldOffset(42)]
            internal byte m_nSourceLight1Color;

            [FieldOffset(43)]
            internal byte m_nSourceLight2Color;

            [FieldOffset(44)]
            internal byte m_nReplaceTexture;

            [FieldOffset(45)]
            internal byte m_nAnimLoop1;

            [FieldOffset(46)]
            internal byte m_nAnimLoop2;

            [FieldOffset(47)]
            internal byte m_nAnimLoop3;

            [FieldOffset(48)]
            internal __IntPtr m_pTileData;

            [FieldOffset(56)]
            internal int m_nTriggers;

            [FieldOffset(60)]
            internal int m_nTriggerSize;

            [FieldOffset(64)]
            internal __IntPtr m_poidTriggers;

            [FieldOffset(72)]
            internal global::NWN.LowLevel.CExoArrayList.__Internal m_aDoors;

            [FieldOffset(88)]
            internal int m_bMainLightColorChange;

            [FieldOffset(92)]
            internal int m_bSourceLightColorChange;

            [FieldOffset(96)]
            internal int m_bFlaggedAsProblem;

            [FieldOffset(100)]
            internal int m_bHasPlaceableWithWalkMesh;

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTileC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTileC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile10AddTriggerEj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddTrigger(__IntPtr __instance, uint oidTrigger);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile16ClearLineOfSightEi6VectorS0_PS0_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ClearLineOfSight(__IntPtr __instance, int nDirectionHeuristic, global::NWN.LowLevel.Vector.__Internal vSource, global::NWN.LowLevel.Vector.__Internal vTarget, __IntPtr vImpact);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile26ClippedLineSegmentWalkableEffffPfS0_S0_S0_S0_S0_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ClippedLineSegmentWalkable(__IntPtr __instance, float fStartX, float fStartY, float fEndX, float fEndY, float* fClipStartX, float* fClipStartY, float* fClipEndX, float* fClipEndY, float* fClipMinZ, float* fClipMaxZ);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile25ComputeClippedLineSegmentE6VectorS0_PS0_S1_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ComputeClippedLineSegment(__IntPtr __instance, global::NWN.LowLevel.Vector.__Internal vSource, global::NWN.LowLevel.Vector.__Internal vTarget, __IntPtr vClipSource, __IntPtr vClipTarget);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile13ComputeHeightE6Vector", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float ComputeHeight(__IntPtr __instance, global::NWN.LowLevel.Vector.__Internal vPosition);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile17FindClosestRegionEff", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FindClosestRegion(__IntPtr __instance, float fX, float fY);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile7GetExitEiPfS0_Pi", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetExit(__IntPtr __instance, int nExit, float* fX, float* fY, int* nRegion);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile13GetExitNumberEff", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetExitNumber(__IntPtr __instance, float fX, float fY);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile15GetRegionCoordsEiPfS0_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRegionCoords(__IntPtr __instance, int nRegion, float* fX, float* fY);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile17GetRegionEntranceEff", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRegionEntrance(__IntPtr __instance, float fX, float fY);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile18GetSurfaceMaterialE6Vector", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetSurfaceMaterial(__IntPtr __instance, global::NWN.LowLevel.Vector.__Internal vPosition);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile21IntersectLineSegmentsEffffffffPfS0_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int IntersectLineSegments(__IntPtr __instance, float fX1, float fY1, float fX2, float fY2, float fX3, float fY3, float fX4, float fY4, float* fXIntersect, float* fYIntersect);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile9InTriggerE6VectorP13CExoArrayListIjE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int InTrigger(__IntPtr __instance, global::NWN.LowLevel.Vector.__Internal vPosition, __IntPtr aTriggers);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile12LoadWalkMeshEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LoadWalkMesh(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile20NoNonWalkPolysOnTileEfffffffi", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int NoNonWalkPolysOnTile(__IntPtr __instance, float fSourceX, float fSourceY, float fTargetX, float fTargetY, float fMinZ, float fMaxZ, float fPersonalSpace, int bTestSinglePoint);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile17PlotIntraTilePathEP7CNWAreaP20CPathfindInformationffffj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PlotIntraTilePath(__IntPtr __instance, __IntPtr pWalkGeometry, __IntPtr pPathfindInformation, float fCurrentIntraTileX, float fCurrentIntraTileY, float fInterTileStartX, float fInterTileStartY, uint nMaxTimeAllowed);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile11GetTileDataEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetTileData(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile11SetTileDataEP11CNWTileData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetTileData(__IntPtr __instance, __IntPtr pTileData);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile13GetTotalExitsEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetTotalExits(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN8CNWSTile11GetWalkMeshEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetWalkMesh(__IntPtr @return, __IntPtr __instance);
        }

        internal static new CNWSTile __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CNWSTile(native.ToPointer(), skipVTables);
        }

        internal static new CNWSTile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CNWSTile)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static new CNWSTile __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new System.Exception("No managed instance was found");
            var result = (CNWSTile)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static CNWSTile __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CNWSTile(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NWN.LowLevel.CNWSTile.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private CNWSTile(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CNWSTile(void* native, bool skipVTables = false)
            : base((void*) native)
        {
            if (native == null)
                return;
            if (!skipVTables)
                SetupVTables(true);
        }

        public CNWSTile()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NWN.LowLevel.CNWSTile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "NWN.LowLevel.CNWSTile");
        }

        public CNWSTile(global::NWN.LowLevel.CNWSTile _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NWN.LowLevel.CNWSTile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "NWN.LowLevel.CNWSTile");
        }

        public void AddTrigger(uint oidTrigger)
        {
            __Internal.AddTrigger(__Instance, oidTrigger);
        }

        public int ClearLineOfSight(int nDirectionHeuristic, global::NWN.LowLevel.Vector vSource, global::NWN.LowLevel.Vector vTarget, global::NWN.LowLevel.Vector vImpact)
        {
            if (ReferenceEquals(vSource, null))
                throw new global::System.ArgumentNullException("vSource", "Cannot be null because it is passed by value.");
            var __arg1 = vSource.__Instance;
            if (ReferenceEquals(vTarget, null))
                throw new global::System.ArgumentNullException("vTarget", "Cannot be null because it is passed by value.");
            var __arg2 = vTarget.__Instance;
            var __arg3 = vImpact is null ? __IntPtr.Zero : vImpact.__Instance;
            var __ret = __Internal.ClearLineOfSight(__Instance, nDirectionHeuristic, *(global::NWN.LowLevel.Vector.__Internal*) __arg1, *(global::NWN.LowLevel.Vector.__Internal*) __arg2, __arg3);
            return __ret;
        }

        public int ClippedLineSegmentWalkable(float fStartX, float fStartY, float fEndX, float fEndY, ref float fClipStartX, ref float fClipStartY, ref float fClipEndX, ref float fClipEndY, ref float fClipMinZ, ref float fClipMaxZ)
        {
            fixed (float* __fClipStartX4 = &fClipStartX)
            {
                var __arg4 = __fClipStartX4;
                fixed (float* __fClipStartY5 = &fClipStartY)
                {
                    var __arg5 = __fClipStartY5;
                    fixed (float* __fClipEndX6 = &fClipEndX)
                    {
                        var __arg6 = __fClipEndX6;
                        fixed (float* __fClipEndY7 = &fClipEndY)
                        {
                            var __arg7 = __fClipEndY7;
                            fixed (float* __fClipMinZ8 = &fClipMinZ)
                            {
                                var __arg8 = __fClipMinZ8;
                                fixed (float* __fClipMaxZ9 = &fClipMaxZ)
                                {
                                    var __arg9 = __fClipMaxZ9;
                                    var __ret = __Internal.ClippedLineSegmentWalkable(__Instance, fStartX, fStartY, fEndX, fEndY, __arg4, __arg5, __arg6, __arg7, __arg8, __arg9);
                                    return __ret;
                                }
                            }
                        }
                    }
                }
            }
        }

        public int ComputeClippedLineSegment(global::NWN.LowLevel.Vector vSource, global::NWN.LowLevel.Vector vTarget, global::NWN.LowLevel.Vector vClipSource, global::NWN.LowLevel.Vector vClipTarget)
        {
            if (ReferenceEquals(vSource, null))
                throw new global::System.ArgumentNullException("vSource", "Cannot be null because it is passed by value.");
            var __arg0 = vSource.__Instance;
            if (ReferenceEquals(vTarget, null))
                throw new global::System.ArgumentNullException("vTarget", "Cannot be null because it is passed by value.");
            var __arg1 = vTarget.__Instance;
            var __arg2 = vClipSource is null ? __IntPtr.Zero : vClipSource.__Instance;
            var __arg3 = vClipTarget is null ? __IntPtr.Zero : vClipTarget.__Instance;
            var __ret = __Internal.ComputeClippedLineSegment(__Instance, *(global::NWN.LowLevel.Vector.__Internal*) __arg0, *(global::NWN.LowLevel.Vector.__Internal*) __arg1, __arg2, __arg3);
            return __ret;
        }

        public float ComputeHeight(global::NWN.LowLevel.Vector vPosition)
        {
            if (ReferenceEquals(vPosition, null))
                throw new global::System.ArgumentNullException("vPosition", "Cannot be null because it is passed by value.");
            var __arg0 = vPosition.__Instance;
            var __ret = __Internal.ComputeHeight(__Instance, *(global::NWN.LowLevel.Vector.__Internal*) __arg0);
            return __ret;
        }

        public int FindClosestRegion(float fX, float fY)
        {
            var __ret = __Internal.FindClosestRegion(__Instance, fX, fY);
            return __ret;
        }

        public int GetExit(int nExit, ref float fX, ref float fY, ref int nRegion)
        {
            fixed (float* __fX1 = &fX)
            {
                var __arg1 = __fX1;
                fixed (float* __fY2 = &fY)
                {
                    var __arg2 = __fY2;
                    fixed (int* __nRegion3 = &nRegion)
                    {
                        var __arg3 = __nRegion3;
                        var __ret = __Internal.GetExit(__Instance, nExit, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        public int GetExitNumber(float fX, float fY)
        {
            var __ret = __Internal.GetExitNumber(__Instance, fX, fY);
            return __ret;
        }

        public int GetRegionCoords(int nRegion, ref float fX, ref float fY)
        {
            fixed (float* __fX1 = &fX)
            {
                var __arg1 = __fX1;
                fixed (float* __fY2 = &fY)
                {
                    var __arg2 = __fY2;
                    var __ret = __Internal.GetRegionCoords(__Instance, nRegion, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        public int GetRegionEntrance(float fX, float fY)
        {
            var __ret = __Internal.GetRegionEntrance(__Instance, fX, fY);
            return __ret;
        }

        public int GetSurfaceMaterial(global::NWN.LowLevel.Vector vPosition)
        {
            if (ReferenceEquals(vPosition, null))
                throw new global::System.ArgumentNullException("vPosition", "Cannot be null because it is passed by value.");
            var __arg0 = vPosition.__Instance;
            var __ret = __Internal.GetSurfaceMaterial(__Instance, *(global::NWN.LowLevel.Vector.__Internal*) __arg0);
            return __ret;
        }

        public int IntersectLineSegments(float fX1, float fY1, float fX2, float fY2, float fX3, float fY3, float fX4, float fY4, ref float fXIntersect, ref float fYIntersect)
        {
            fixed (float* __fXIntersect8 = &fXIntersect)
            {
                var __arg8 = __fXIntersect8;
                fixed (float* __fYIntersect9 = &fYIntersect)
                {
                    var __arg9 = __fYIntersect9;
                    var __ret = __Internal.IntersectLineSegments(__Instance, fX1, fY1, fX2, fY2, fX3, fY3, fX4, fY4, __arg8, __arg9);
                    return __ret;
                }
            }
        }

        public int InTrigger(global::NWN.LowLevel.Vector vPosition, global::NWN.LowLevel.CExoArrayList<uint> aTriggers)
        {
            if (ReferenceEquals(vPosition, null))
                throw new global::System.ArgumentNullException("vPosition", "Cannot be null because it is passed by value.");
            var __arg0 = vPosition.__Instance;
            var __arg1 = aTriggers is null ? __IntPtr.Zero : aTriggers.__Instance;
            var __ret = __Internal.InTrigger(__Instance, *(global::NWN.LowLevel.Vector.__Internal*) __arg0, __arg1);
            return __ret;
        }

        public int LoadWalkMesh()
        {
            var __ret = __Internal.LoadWalkMesh(__Instance);
            return __ret;
        }

        public int NoNonWalkPolysOnTile(float fSourceX, float fSourceY, float fTargetX, float fTargetY, float fMinZ, float fMaxZ, float fPersonalSpace, int bTestSinglePoint)
        {
            var __ret = __Internal.NoNonWalkPolysOnTile(__Instance, fSourceX, fSourceY, fTargetX, fTargetY, fMinZ, fMaxZ, fPersonalSpace, bTestSinglePoint);
            return __ret;
        }

        public uint PlotIntraTilePath(global::NWN.LowLevel.CNWArea pWalkGeometry, global::NWN.LowLevel.CPathfindInformation pPathfindInformation, float fCurrentIntraTileX, float fCurrentIntraTileY, float fInterTileStartX, float fInterTileStartY, uint nMaxTimeAllowed)
        {
            var __arg0 = pWalkGeometry is null ? __IntPtr.Zero : pWalkGeometry.__Instance;
            var __arg1 = pPathfindInformation is null ? __IntPtr.Zero : pPathfindInformation.__Instance;
            var __ret = __Internal.PlotIntraTilePath(__Instance, __arg0, __arg1, fCurrentIntraTileX, fCurrentIntraTileY, fInterTileStartX, fInterTileStartY, nMaxTimeAllowed);
            return __ret;
        }

        public virtual void SetMainLightColor(byte nMainLight1Color, byte nMainLight2Color)
        {
            var ___SetMainLightColorDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr_byte_byte>(0, 2);
            ___SetMainLightColorDelegate(__Instance, nMainLight1Color, nMainLight2Color);
        }

        public virtual void SetSourceLightColor(byte nSourceLight1Color, byte nSourceLight2Color)
        {
            var ___SetSourceLightColorDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr_byte_byte>(0, 3);
            ___SetSourceLightColorDelegate(__Instance, nSourceLight1Color, nSourceLight2Color);
        }

        public global::NWN.LowLevel.CNWTileData MPTileData
        {
            get
            {
                var __result0 = global::NWN.LowLevel.CNWTileData.__GetOrCreateInstance(((__Internal*)__Instance)->m_pTileData, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->m_pTileData = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int MNTriggers
        {
            get
            {
                return ((__Internal*)__Instance)->m_nTriggers;
            }

            set
            {
                ((__Internal*)__Instance)->m_nTriggers = value;
            }
        }

        public int MNTriggerSize
        {
            get
            {
                return ((__Internal*)__Instance)->m_nTriggerSize;
            }

            set
            {
                ((__Internal*)__Instance)->m_nTriggerSize = value;
            }
        }

        public uint* MPoidTriggers
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->m_poidTriggers;
            }

            set
            {
                ((__Internal*)__Instance)->m_poidTriggers = (__IntPtr) value;
            }
        }

        public global::NWN.LowLevel.CExoArrayList<uint> MADoors
        {
            get
            {
                return global::NWN.LowLevel.CExoArrayList<uint>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_aDoors));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->m_aDoors = *(global::NWN.LowLevel.CExoArrayList.__Internal*) value.__Instance;
            }
        }

        public int MBMainLightColorChange
        {
            get
            {
                return ((__Internal*)__Instance)->m_bMainLightColorChange;
            }

            set
            {
                ((__Internal*)__Instance)->m_bMainLightColorChange = value;
            }
        }

        public int MBSourceLightColorChange
        {
            get
            {
                return ((__Internal*)__Instance)->m_bSourceLightColorChange;
            }

            set
            {
                ((__Internal*)__Instance)->m_bSourceLightColorChange = value;
            }
        }

        public int MBFlaggedAsProblem
        {
            get
            {
                return ((__Internal*)__Instance)->m_bFlaggedAsProblem;
            }

            set
            {
                ((__Internal*)__Instance)->m_bFlaggedAsProblem = value;
            }
        }

        public int MBHasPlaceableWithWalkMesh
        {
            get
            {
                return ((__Internal*)__Instance)->m_bHasPlaceableWithWalkMesh;
            }

            set
            {
                ((__Internal*)__Instance)->m_bHasPlaceableWithWalkMesh = value;
            }
        }

        public global::NWN.LowLevel.CNWTileData TileData
        {
            get
            {
                var __ret = __Internal.GetTileData(__Instance);
                var __result0 = global::NWN.LowLevel.CNWTileData.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            set
            {
                var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                __Internal.SetTileData(__Instance, __arg0);
            }
        }

        public int TotalExits
        {
            get
            {
                var __ret = __Internal.GetTotalExits(__Instance);
                return __ret;
            }
        }

        public global::NWN.LowLevel.CResRef WalkMesh
        {
            get
            {
                var __ret = new global::NWN.LowLevel.CResRef.__Internal();
                __Internal.GetWalkMesh(new IntPtr(&__ret), __Instance);
                return global::NWN.LowLevel.CResRef.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~CNWSTile()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CNWSTile.__GetInstance(__instance);
            __target.Dispose(true);
        }

        // void SetMainLightColor(uint8_t nMainLight1Color, uint8_t nMainLight2Color)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr_byte_byte _SetMainLightColorDelegateInstance;

        private static void _SetMainLightColorDelegateHook(__IntPtr __instance, byte nMainLight1Color, byte nMainLight2Color)
        {
            var __target = global::NWN.LowLevel.CNWSTile.__GetInstance(__instance);
            __target.SetMainLightColor(nMainLight1Color, nMainLight2Color);
        }

        // void SetSourceLightColor(uint8_t nSourceLight1Color, uint8_t nSourceLight2Color)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr_byte_byte _SetSourceLightColorDelegateInstance;

        private static void _SetSourceLightColorDelegateHook(__IntPtr __instance, byte nSourceLight1Color, byte nSourceLight2Color)
        {
            var __target = global::NWN.LowLevel.CNWSTile.__GetInstance(__instance);
            __target.SetSourceLightColor(nSourceLight1Color, nSourceLight2Color);
        }

        internal static new class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[3];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _SetMainLightColorDelegateInstance += _SetMainLightColorDelegateHook;
                _SetSourceLightColorDelegateInstance += _SetSourceLightColorDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetMainLightColorDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetSourceLightColorDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6);
                            ManagedVTablesDtorOnly[0][1] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6);
                            ManagedVTables[0][1] = Thunks[0];
                            ManagedVTables[0][2] = Thunks[1];
                            ManagedVTables[0][3] = Thunks[2];
                            VTables.Methods[0] = new Delegate[6];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        internal override CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal override void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__S_CExoString___S_CNWSScriptVar
        {
            [FieldOffset(0)]
            internal global::NWN.LowLevel.CExoString.__Internal first;

            [FieldOffset(16)]
            internal global::NWN.LowLevel.CNWSScriptVar.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_N___cxx11_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___S_CachedRulesetEntry
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_N___cxx11_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::NWN.LowLevel.CachedRulesetEntry.__Internal second;
        }
    }

}
namespace Std
{
    namespace Hashtable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public unsafe partial struct __Internalc__N_std_S__Hashtable____S_CExoString___N_std_S_pair__1S0____S_CNWSScriptVar___N_std_S_allocator__S1____N_std_N___detail_S__Select1st___N_std_S_equal_to__S0____N_std_S_hash__S0____N_std_N___detail_S__Mod_range_hashing___N_std_N___detail_S__Default_ranged_hash___N_std_N___detail_S__Prime_rehash_policy___N_std_N___detail_S__Hashtable_traits__Vb1_Vb0_Vb1
        {
            [FieldOffset(0)]
            internal __IntPtr _M_buckets;

            [FieldOffset(8)]
            internal ulong _M_bucket_count;

            [FieldOffset(16)]
            internal global::Std.Detail.HashNodeBase.__Internal _M_before_begin;

            [FieldOffset(24)]
            internal ulong _M_element_count;

            [FieldOffset(32)]
            internal global::Std.Detail.PrimeRehashPolicy.__Internal _M_rehash_policy;

            [FieldOffset(48)]
            internal __IntPtr _M_single_bucket;
        }
    }
}
