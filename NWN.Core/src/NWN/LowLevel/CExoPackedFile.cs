// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NWN.LowLevel
{
    public unsafe partial class CExoPackedFile : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr vptr_CExoPackedFile;

            [FieldOffset(8)]
            internal global::NWN.LowLevel.CExoString.__Internal m_sFileName;

            [FieldOffset(24)]
            internal ushort m_wDrives;

            [FieldOffset(28)]
            internal uint m_nFileSize;

            [FieldOffset(32)]
            internal __IntPtr m_pExoFile;

            [FieldOffset(40)]
            internal __IntPtr m_pAsyncExoFile;

            [FieldOffset(48)]
            internal int m_nRefCount;

            [FieldOffset(52)]
            internal int m_nAsyncRefCount;

            [FieldOffset(56)]
            internal int m_bLoaded;

            [FieldOffset(60)]
            internal int m_bAsyncLoaded;

            [FieldOffset(64)]
            internal int m_bHeaderLoaded;

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN14CExoPackedFileC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN14CExoPackedFileC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NWNXLib", EntryPoint = "_ZN14CExoPackedFile22ReadNWCompressedBufferEPvjj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint ReadNWCompressedBuffer(__IntPtr __instance, __IntPtr outBuffer, uint outBufSize, uint readLength);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NWN.LowLevel.CExoPackedFile> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NWN.LowLevel.CExoPackedFile>();

        protected bool __ownsNativeInstance;

        internal static CExoPackedFile __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CExoPackedFile(native.ToPointer(), skipVTables);
        }

        internal static CExoPackedFile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CExoPackedFile)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CExoPackedFile __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new System.Exception("No managed instance was found");
            var result = (CExoPackedFile)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static CExoPackedFile __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CExoPackedFile(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NWN.LowLevel.CExoPackedFile.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private CExoPackedFile(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CExoPackedFile(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
            if (!skipVTables)
                SetupVTables(true);
        }

        public CExoPackedFile()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NWN.LowLevel.CExoPackedFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "NWN.LowLevel.CExoPackedFile");
        }

        public CExoPackedFile(global::NWN.LowLevel.CExoPackedFile _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NWN.LowLevel.CExoPackedFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "NWN.LowLevel.CExoPackedFile");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::NWN.LowLevel.CExoPackedFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::NWN.LowLevel.CExoPackedFile.__Internal*) __Instance)->vptr_CExoPackedFile = __VTables.Tables[0];
            if (disposing)
            {
                var ___dtorDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr>(0, 0);
                ___dtorDelegate(__Instance);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public virtual void AddRefCount()
        {
            var ___AddRefCountDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr>(0, 2);
            ___AddRefCountDelegate(__Instance);
        }

        public virtual void AddAsyncRefCount()
        {
            var ___AddAsyncRefCountDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr>(0, 3);
            ___AddAsyncRefCountDelegate(__Instance);
        }

        public virtual int CloseFile()
        {
            var ___CloseFileDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 4);
            var __ret = ___CloseFileDelegate(__Instance);
            return __ret;
        }

        public virtual int CloseAsyncFile()
        {
            var ___CloseAsyncFileDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 5);
            var __ret = ___CloseAsyncFileDelegate(__Instance);
            return __ret;
        }

        public virtual void DeleteRefCount()
        {
            var ___DeleteRefCountDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr>(0, 6);
            ___DeleteRefCountDelegate(__Instance);
        }

        public virtual void DeleteAsyncRefCount()
        {
            var ___DeleteAsyncRefCountDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr>(0, 7);
            ___DeleteAsyncRefCountDelegate(__Instance);
        }

        public virtual uint GetResourceSize(global::NWN.LowLevel.RESID nID)
        {
            var ___GetResourceSizeDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_uint___IntPtr_NWN_LowLevel_RESID___Internal>(0, 10);
            if (ReferenceEquals(nID, null))
                throw new global::System.ArgumentNullException("nID", "Cannot be null because it is passed by value.");
            var __arg0 = nID.__Instance;
            var __ret = ___GetResourceSizeDelegate(__Instance, *(global::NWN.LowLevel.RESID.__Internal*) __arg0);
            return __ret;
        }

        public virtual int Initialize()
        {
            var ___InitializeDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 11);
            var __ret = ___InitializeDelegate(__Instance);
            return __ret;
        }

        public virtual int OpenFile()
        {
            var ___OpenFileDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 12);
            var __ret = ___OpenFileDelegate(__Instance);
            return __ret;
        }

        public virtual int OpenFile(byte* pCipher)
        {
            var ___OpenFile_1Delegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr_bytePtr>(0, 13);
            var __ret = ___OpenFile_1Delegate(__Instance, pCipher);
            return __ret;
        }

        public virtual int OpenAsyncFile()
        {
            var ___OpenAsyncFileDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 14);
            var __ret = ___OpenAsyncFileDelegate(__Instance);
            return __ret;
        }

        public virtual uint ReadResource(global::NWN.LowLevel.RESID nID, __IntPtr pData, uint nSize, uint nDataOffset)
        {
            var ___ReadResourceDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_uint___IntPtr_NWN_LowLevel_RESID___Internal___IntPtr_uint_uint>(0, 15);
            if (ReferenceEquals(nID, null))
                throw new global::System.ArgumentNullException("nID", "Cannot be null because it is passed by value.");
            var __arg0 = nID.__Instance;
            var __ret = ___ReadResourceDelegate(__Instance, *(global::NWN.LowLevel.RESID.__Internal*) __arg0, pData, nSize, nDataOffset);
            return __ret;
        }

        public virtual void ReadResourceAsync(global::NWN.LowLevel.RESID nID, __IntPtr pData, uint nSize, uint nDataOffset)
        {
            var ___ReadResourceAsyncDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Action___IntPtr_NWN_LowLevel_RESID___Internal___IntPtr_uint_uint>(0, 16);
            if (ReferenceEquals(nID, null))
                throw new global::System.ArgumentNullException("nID", "Cannot be null because it is passed by value.");
            var __arg0 = nID.__Instance;
            ___ReadResourceAsyncDelegate(__Instance, *(global::NWN.LowLevel.RESID.__Internal*) __arg0, pData, nSize, nDataOffset);
        }

        public virtual int LoadHeader(byte nType)
        {
            var ___LoadHeaderDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr_byte>(0, 17);
            var __ret = ___LoadHeaderDelegate(__Instance, nType);
            return __ret;
        }

        public virtual int UnloadHeader()
        {
            var ___UnloadHeaderDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func_int___IntPtr>(0, 18);
            var __ret = ___UnloadHeaderDelegate(__Instance);
            return __ret;
        }

        public uint ReadNWCompressedBuffer(__IntPtr outBuffer, uint outBufSize, uint readLength)
        {
            var __ret = __Internal.ReadNWCompressedBuffer(__Instance, outBuffer, outBufSize, readLength);
            return __ret;
        }

        public global::NWN.LowLevel.CExoString MSFileName
        {
            get
            {
                return global::NWN.LowLevel.CExoString.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_sFileName));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->m_sFileName = *(global::NWN.LowLevel.CExoString.__Internal*) value.__Instance;
            }
        }

        public ushort MWDrives
        {
            get
            {
                return ((__Internal*)__Instance)->m_wDrives;
            }

            set
            {
                ((__Internal*)__Instance)->m_wDrives = value;
            }
        }

        public uint MNFileSize
        {
            get
            {
                return ((__Internal*)__Instance)->m_nFileSize;
            }

            set
            {
                ((__Internal*)__Instance)->m_nFileSize = value;
            }
        }

        public global::NWN.LowLevel.CExoFile MPExoFile
        {
            get
            {
                var __result0 = global::NWN.LowLevel.CExoFile.__GetOrCreateInstance(((__Internal*)__Instance)->m_pExoFile, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->m_pExoFile = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::NWN.LowLevel.CExoFile MPAsyncExoFile
        {
            get
            {
                var __result0 = global::NWN.LowLevel.CExoFile.__GetOrCreateInstance(((__Internal*)__Instance)->m_pAsyncExoFile, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->m_pAsyncExoFile = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int MNRefCount
        {
            get
            {
                return ((__Internal*)__Instance)->m_nRefCount;
            }

            set
            {
                ((__Internal*)__Instance)->m_nRefCount = value;
            }
        }

        public int MNAsyncRefCount
        {
            get
            {
                return ((__Internal*)__Instance)->m_nAsyncRefCount;
            }

            set
            {
                ((__Internal*)__Instance)->m_nAsyncRefCount = value;
            }
        }

        public int MBLoaded
        {
            get
            {
                return ((__Internal*)__Instance)->m_bLoaded;
            }

            set
            {
                ((__Internal*)__Instance)->m_bLoaded = value;
            }
        }

        public int MBAsyncLoaded
        {
            get
            {
                return ((__Internal*)__Instance)->m_bAsyncLoaded;
            }

            set
            {
                ((__Internal*)__Instance)->m_bAsyncLoaded = value;
            }
        }

        public int MBHeaderLoaded
        {
            get
            {
                return ((__Internal*)__Instance)->m_bHeaderLoaded;
            }

            set
            {
                ((__Internal*)__Instance)->m_bHeaderLoaded = value;
            }
        }

        public virtual global::NWN.LowLevel.CExoFile File
        {
            get
            {
                var ___GetFileDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr>(0, 8);
                var __ret = ___GetFileDelegate(__Instance);
                var __result0 = global::NWN.LowLevel.CExoFile.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public virtual global::NWN.LowLevel.CExoFile AsyncFile
        {
            get
            {
                var ___GetAsyncFileDelegate = __VTables.GetMethodDelegate<global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr>(0, 9);
                var __ret = ___GetAsyncFileDelegate(__Instance);
                var __result0 = global::NWN.LowLevel.CExoFile.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        #region Virtual table interop

        // virtual ~CExoPackedFile()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            __target.Dispose(true);
        }

        // void AddRefCount()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _AddRefCountDelegateInstance;

        private static void _AddRefCountDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            __target.AddRefCount();
        }

        // void AddAsyncRefCount()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _AddAsyncRefCountDelegateInstance;

        private static void _AddAsyncRefCountDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            __target.AddAsyncRefCount();
        }

        // BOOL CloseFile()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _CloseFileDelegateInstance;

        private static int _CloseFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.CloseFile();
        }

        // BOOL CloseAsyncFile()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _CloseAsyncFileDelegateInstance;

        private static int _CloseAsyncFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.CloseAsyncFile();
        }

        // void DeleteRefCount()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _DeleteRefCountDelegateInstance;

        private static void _DeleteRefCountDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            __target.DeleteRefCount();
        }

        // void DeleteAsyncRefCount()
        private static global::NWN.LowLevel.Delegates.Action___IntPtr _DeleteAsyncRefCountDelegateInstance;

        private static void _DeleteAsyncRefCountDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            __target.DeleteAsyncRefCount();
        }

        // CExoFile * GetFile()
        private static global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr _GetFileDelegateInstance;

        private static __IntPtr _GetFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            var __ret = __target.File;
            return __ret is null ? __IntPtr.Zero : __ret.__Instance;
        }

        // CExoFile * GetAsyncFile()
        private static global::NWN.LowLevel.Delegates.Func___IntPtr___IntPtr _GetAsyncFileDelegateInstance;

        private static __IntPtr _GetAsyncFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            var __ret = __target.AsyncFile;
            return __ret is null ? __IntPtr.Zero : __ret.__Instance;
        }

        // uint32_t GetResourceSize(RESID nID)
        private static global::NWN.LowLevel.Delegates.Func_uint___IntPtr_NWN_LowLevel_RESID___Internal _GetResourceSizeDelegateInstance;

        private static uint _GetResourceSizeDelegateHook(__IntPtr __instance, global::NWN.LowLevel.RESID.__Internal nID)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.GetResourceSize(global::NWN.LowLevel.RESID.__CreateInstance(nID));
        }

        // BOOL Initialize()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _InitializeDelegateInstance;

        private static int _InitializeDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.Initialize();
        }

        // BOOL OpenFile()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _OpenFileDelegateInstance;

        private static int _OpenFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.OpenFile();
        }

        // BOOL OpenFile(uint8_t * pCipher)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr_bytePtr _OpenFile_1DelegateInstance;

        private static int _OpenFile_1DelegateHook(__IntPtr __instance, byte* pCipher)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.OpenFile(pCipher);
        }

        // BOOL OpenAsyncFile()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _OpenAsyncFileDelegateInstance;

        private static int _OpenAsyncFileDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.OpenAsyncFile();
        }

        // uint32_t ReadResource(RESID nID, void * pData, uint32_t nSize, uint32_t nDataOffset)
        private static global::NWN.LowLevel.Delegates.Func_uint___IntPtr_NWN_LowLevel_RESID___Internal___IntPtr_uint_uint _ReadResourceDelegateInstance;

        private static uint _ReadResourceDelegateHook(__IntPtr __instance, global::NWN.LowLevel.RESID.__Internal nID, __IntPtr pData, uint nSize, uint nDataOffset)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.ReadResource(global::NWN.LowLevel.RESID.__CreateInstance(nID), pData, nSize, nDataOffset);
        }

        // void ReadResourceAsync(RESID nID, void * pData, uint32_t nSize, uint32_t nDataOffset)
        private static global::NWN.LowLevel.Delegates.Action___IntPtr_NWN_LowLevel_RESID___Internal___IntPtr_uint_uint _ReadResourceAsyncDelegateInstance;

        private static void _ReadResourceAsyncDelegateHook(__IntPtr __instance, global::NWN.LowLevel.RESID.__Internal nID, __IntPtr pData, uint nSize, uint nDataOffset)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            __target.ReadResourceAsync(global::NWN.LowLevel.RESID.__CreateInstance(nID), pData, nSize, nDataOffset);
        }

        // BOOL LoadHeader(uint8_t nType = 0)
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr_byte _LoadHeaderDelegateInstance;

        private static int _LoadHeaderDelegateHook(__IntPtr __instance, byte nType)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.LoadHeader(nType);
        }

        // BOOL UnloadHeader()
        private static global::NWN.LowLevel.Delegates.Func_int___IntPtr _UnloadHeaderDelegateInstance;

        private static int _UnloadHeaderDelegateHook(__IntPtr __instance)
        {
            var __target = global::NWN.LowLevel.CExoPackedFile.__GetInstance(__instance);
            return __target.UnloadHeader();
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[18];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _AddRefCountDelegateInstance += _AddRefCountDelegateHook;
                _AddAsyncRefCountDelegateInstance += _AddAsyncRefCountDelegateHook;
                _CloseFileDelegateInstance += _CloseFileDelegateHook;
                _CloseAsyncFileDelegateInstance += _CloseAsyncFileDelegateHook;
                _DeleteRefCountDelegateInstance += _DeleteRefCountDelegateHook;
                _DeleteAsyncRefCountDelegateInstance += _DeleteAsyncRefCountDelegateHook;
                _GetFileDelegateInstance += _GetFileDelegateHook;
                _GetAsyncFileDelegateInstance += _GetAsyncFileDelegateHook;
                _GetResourceSizeDelegateInstance += _GetResourceSizeDelegateHook;
                _InitializeDelegateInstance += _InitializeDelegateHook;
                _OpenFileDelegateInstance += _OpenFileDelegateHook;
                _OpenFile_1DelegateInstance += _OpenFile_1DelegateHook;
                _OpenAsyncFileDelegateInstance += _OpenAsyncFileDelegateHook;
                _ReadResourceDelegateInstance += _ReadResourceDelegateHook;
                _ReadResourceAsyncDelegateInstance += _ReadResourceAsyncDelegateHook;
                _LoadHeaderDelegateInstance += _LoadHeaderDelegateHook;
                _UnloadHeaderDelegateInstance += _UnloadHeaderDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AddRefCountDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AddAsyncRefCountDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_CloseFileDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_CloseAsyncFileDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_DeleteRefCountDelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_DeleteAsyncRefCountDelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetFileDelegateInstance);
                Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetAsyncFileDelegateInstance);
                Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetResourceSizeDelegateInstance);
                Thunks[10] = Marshal.GetFunctionPointerForDelegate(_InitializeDelegateInstance);
                Thunks[11] = Marshal.GetFunctionPointerForDelegate(_OpenFileDelegateInstance);
                Thunks[12] = Marshal.GetFunctionPointerForDelegate(_OpenFile_1DelegateInstance);
                Thunks[13] = Marshal.GetFunctionPointerForDelegate(_OpenAsyncFileDelegateInstance);
                Thunks[14] = Marshal.GetFunctionPointerForDelegate(_ReadResourceDelegateInstance);
                Thunks[15] = Marshal.GetFunctionPointerForDelegate(_ReadResourceAsyncDelegateInstance);
                Thunks[16] = Marshal.GetFunctionPointerForDelegate(_LoadHeaderDelegateInstance);
                Thunks[17] = Marshal.GetFunctionPointerForDelegate(_UnloadHeaderDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 21);
                            ManagedVTablesDtorOnly[0][1] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 21);
                            ManagedVTables[0][1] = Thunks[0];
                            ManagedVTables[0][2] = Thunks[1];
                            ManagedVTables[0][3] = Thunks[2];
                            ManagedVTables[0][4] = Thunks[3];
                            ManagedVTables[0][5] = Thunks[4];
                            ManagedVTables[0][6] = Thunks[5];
                            ManagedVTables[0][7] = Thunks[6];
                            ManagedVTables[0][8] = Thunks[7];
                            ManagedVTables[0][9] = Thunks[8];
                            ManagedVTables[0][10] = Thunks[9];
                            ManagedVTables[0][11] = Thunks[10];
                            ManagedVTables[0][12] = Thunks[11];
                            ManagedVTables[0][13] = Thunks[12];
                            ManagedVTables[0][14] = Thunks[13];
                            ManagedVTables[0][15] = Thunks[14];
                            ManagedVTables[0][16] = Thunks[15];
                            ManagedVTables[0][17] = Thunks[16];
                            ManagedVTables[0][18] = Thunks[17];
                            VTables.Methods[0] = new Delegate[21];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__S_CExoString___S_CNWSScriptVar
        {
            [FieldOffset(0)]
            internal global::NWN.LowLevel.CExoString.__Internal first;

            [FieldOffset(16)]
            internal global::NWN.LowLevel.CNWSScriptVar.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_N___cxx11_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___S_CachedRulesetEntry
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_N___cxx11_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::NWN.LowLevel.CachedRulesetEntry.__Internal second;
        }
    }

}
namespace Std
{
    namespace Hashtable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public unsafe partial struct __Internalc__N_std_S__Hashtable____S_CExoString___N_std_S_pair__1S0____S_CNWSScriptVar___N_std_S_allocator__S1____N_std_N___detail_S__Select1st___N_std_S_equal_to__S0____N_std_S_hash__S0____N_std_N___detail_S__Mod_range_hashing___N_std_N___detail_S__Default_ranged_hash___N_std_N___detail_S__Prime_rehash_policy___N_std_N___detail_S__Hashtable_traits__Vb1_Vb0_Vb1
        {
            [FieldOffset(0)]
            internal __IntPtr _M_buckets;

            [FieldOffset(8)]
            internal ulong _M_bucket_count;

            [FieldOffset(16)]
            internal global::Std.Detail.HashNodeBase.__Internal _M_before_begin;

            [FieldOffset(24)]
            internal ulong _M_element_count;

            [FieldOffset(32)]
            internal global::Std.Detail.PrimeRehashPolicy.__Internal _M_rehash_policy;

            [FieldOffset(48)]
            internal __IntPtr _M_single_bucket;
        }
    }
}
